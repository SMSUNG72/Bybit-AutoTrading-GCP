===== BEGIN FILE: app.py =====
from flask import Flask, render_template, request, jsonify
from dotenv import load_dotenv
import os

# 다음 단계에서 만들 trading_bot.py 파일에서 TradingBot 클래스를 가져옵니다.
# 아직 파일이 없어서 오류처럼 보일 수 있지만, 정상입니다.
from trading_bot import TradingBot

# .env 파일에서 환경 변수를 로드합니다.
load_dotenv()

# Flask 웹 애플리케이션 생성
app = Flask(__name__)

# .env 파일에서 Bybit API 키를 가져옵니다.
api_key = os.getenv("BYBIT_API_KEY")
api_secret = os.getenv("BYBIT_API_SECRET")

# API 키가 .env 파일에 설정되지 않은 경우, 오류를 발생시켜 문제를 알려줍니다.
if not api_key or not api_secret:
    raise ValueError("오류: .env 파일에 BYBIT_API_KEY와 BYBIT_API_SECRET을 설정해야 합니다.")

# 자동매매 봇 객체를 단 하나만 생성하여 전역 변수로 관리합니다.
# 이렇게 하면 서버가 실행되는 동안 봇의 상태(실행 여부 등)가 계속 유지됩니다.
bot = TradingBot(api_key=api_key, api_secret=api_secret)


# --- 웹 페이지 주소(URL)와 파이썬 함수를 연결하는 부분 ---

@app.route('/')
def index():
    """
    사용자가 웹 브라우저에서 우리 서버의 기본 주소로 접속했을 때,
    templates 폴더에 있는 index.html 파일을 화면에 보여주는 함수입니다.
    """
    return render_template('index.html')

@app.route('/start', methods=['POST'])
def start_bot():
    """
    웹 UI의 '봇 시작하기' 버튼을 누르면, scripts.js가 이곳으로 요청을 보냅니다.
    웹에서 받은 설정값(JSON)으로 봇을 시작시키는 함수입니다.
    """
    if not bot.is_running:
        params = request.json  # 웹에서 보낸 모든 설정값을 딕셔너리(params)로 받습니다.
        bot.start(params)      # 받은 설정값으로 trading_bot.py의 봇을 시작시킵니다.
        return jsonify({'status': 'success', 'message': '봇이 성공적으로 시작되었습니다.'})
    else:
        return jsonify({'status': 'already_running', 'message': '봇이 이미 실행 중입니다.'})

@app.route('/stop', methods=['POST'])
def stop_bot():
    """
    '봇 종료' 버튼을 누르면 이곳으로 요청이 옵니다.
    실행 중인 봇을 중지시키는 함수입니다.
    """
    if bot.is_running:
        bot.stop()
        return jsonify({'status': 'success', 'message': '봇이 성공적으로 중지되었습니다.'})
    else:
        return jsonify({'status': 'not_running', 'message': '봇이 이미 중지 상태입니다.'})

@app.route('/status')
def get_status():
    """
    웹 UI가 주기적으로 봇의 현재 상태를 물어볼 때 이곳으로 요청이 옵니다.
    봇의 현재 상태(실행 여부, 로그 등)를 JSON 형태로 웹에 전달하는 함수입니다.
    """
    return jsonify(bot.get_status())


# --- 웹 서버 실행 ---

if __name__ == '__main__':
    """
    터미널에서 'python app.py' 명령어로 이 파일을 직접 실행했을 때만
    아래의 웹 서버 실행 코드가 동작합니다.
    """
    # host='0.0.0.0'은 내 PC뿐만 아니라, 같은 네트워크의 다른 기기에서도 접속할 수 있게 합니다.
    # debug=True는 코드 수정 시 서버가 자동으로 재시작되어 개발에 편리합니다.
    app.run(host='0.0.0.0', port=5001, debug=True)
===== END FILE: app.py =====
===== BEGIN FILE: trading_bot.py =====
from pybit.unified_trading import HTTP
import time
import logging
from threading import Thread, Event
import math
import smtplib
from email.mime.text import MIMEText
import random
import string

# 로그 설정
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

class TradingBot:
    def __init__(self, api_key, api_secret):
        try:
            self.session = HTTP(testnet=False, api_key=api_key, api_secret=api_secret)
            logging.info("Bybit API 세션이 성공적으로 초기화되었습니다.")
        except Exception as e:
            logging.error(f"API 세션 초기화 실패: {e}")
            raise

        self.params = {}
        self.is_running = False
        self.stop_event = Event()
        self.thread = None
        self.logs = []
        self.instrument_info = {}
        self.last_position_state = {"size": None, "avg_price": None}
        self.tp_order_link_id = None # 익절 주문 ID를 저장할 변수

        # --- 이메일 설정 (원본 코드와 동일) ---
        self.email_config = {
            "smtp_server": "smtp.naver.com",
            "port": 465,
            "sender_email": "smsung2@naver.com",
            "receiver_email": "smsung2@naver.com",
            "user_id": "smsung2",
            "password": "SBDV8PZYKC4X" # 원본 코드의 비밀번호
        }

    def log(self, message):
        logging.info(message)
        log_entry = f"[{time.strftime('%Y-%m-%d %H:%M:%S')}] {message}"
        self.logs.insert(0, log_entry)
        self.logs = self.logs[:100]

    def _send_email(self, subject, text):
        try:
            cfg = self.email_config
            msg = MIMEText(text)
            msg['Subject'] = subject
            msg['From'] = cfg['sender_email']
            msg['To'] = cfg['receiver_email']

            with smtplib.SMTP_SSL(cfg['smtp_server'], cfg['port']) as server:
                server.login(cfg['user_id'], cfg['password'])
                server.sendmail(cfg['sender_email'], cfg['receiver_email'], msg.as_string())
            self.log(f"이메일 알림 발송 성공: {subject}")
        except Exception as e:
            self.log(f"오류: 이메일 발송 실패 - {e}")

    def get_status(self):
        return {'is_running': self.is_running, 'logs': self.logs}

    def start(self, params):
        if self.is_running:
            self.log("경고: 봇이 이미 실행 중입니다.")
            return
        self.params = params
        self.is_running = True
        self.stop_event.clear()
        self.thread = Thread(target=self._run)
        self.thread.start()
        self.log("봇 스레드를 시작합니다.")

    def stop(self):
        if not self.is_running:
            self.log("경고: 봇이 이미 중지 상태입니다.")
            return
        self.is_running = False
        self.stop_event.set()
        if self.thread:
            self.thread.join(timeout=10)
        try:
            symbol = self.params.get('symbol', 'BTCUSDT')
            self.session.cancel_all_orders(category="linear", symbol=symbol)
            self.log(f"{symbol}의 모든 대기 주문을 취소했습니다.")
        except Exception as e:
            self.log(f"오류: 주문 취소 실패 - {e}")
        self.log("봇 스레드를 중지했습니다.")

    def _get_instrument_info(self, symbol):
        try:
            res = self.session.get_instruments_info(category="linear", symbol=symbol)
            info = res['result']['list'][0]
            self.instrument_info = {
                'qty_step': float(info['lotSizeFilter']['qtyStep']),
                'tick_size': float(info['priceFilter']['tickSize']),
                'min_order_qty': float(info['lotSizeFilter']['minOrderQty'])
            }
            self.instrument_info['qty_precision'] = int(abs(math.log10(self.instrument_info['qty_step']))) if self.instrument_info['qty_step'] > 0 else 0
            self.instrument_info['price_precision'] = int(abs(math.log10(self.instrument_info['tick_size']))) if self.instrument_info['tick_size'] > 0 else 0
            self.log(f"{symbol} 정보 로드 완료: {self.instrument_info}")
        except Exception as e:
            self.log(f"오류: {symbol} 정보 로드 실패 - {e}")
            raise

    def _place_order(self, order_params):
        try:
            order_params['qty'] = str(round(float(order_params['qty']), self.instrument_info['qty_precision']))
            if 'price' in order_params:
                order_params['price'] = str(round(float(order_params['price']), self.instrument_info['price_precision']))

            if float(order_params['qty']) < self.instrument_info['min_order_qty']:
                self.log(f"경고: 계산된 주문 수량({order_params['qty']})이 최소 주문 수량({self.instrument_info['min_order_qty']})보다 작아 주문을 실행하지 않습니다.")
                return None
            
            self.log(f"주문 시도: {order_params}")
            response = self.session.place_order(**order_params)
            self.log(f"주문 응답: {response.get('retMsg')}")
            if response.get('retCode') != 0:
                self.log(f"주문 실패! 응답: {response}")
                return None
            return response
        except Exception as e:
            self.log(f"오류: 주문 실패 - {e}")
            return None

    def _run(self):
        self.log(f"자동매매 로직을 시작합니다. 설정: {self.params}")
        
        try:
            symbol = self.params['symbol']
            leverage = self.params['leverage']
            
            self._get_instrument_info(symbol)
            
            try:
                self.session.switch_position_mode(category="linear", symbol=symbol, mode=3)
                self.log("계정을 헤지 모드로 설정했습니다.")
            except Exception as e:
                if "110025" in str(e) or "110021" in str(e):
                    self.log("정보: 계정이 이미 헤지 모드로 설정되어 있습니다.")
                else:
                    self.log(f"경고: 포지션 모드 설정 실패 - {e}")

            try:
                self.session.set_leverage(category="linear", symbol=symbol, buyLeverage=str(leverage), sellLeverage=str(leverage))
                self.log(f"레버리지를 {leverage}x로 설정했습니다.")
            except Exception as e:
                if "110043" in str(e): self.log(f"정보: 레버리지가 이미 {leverage}x로 설정되어 있어 건너뜁니다.")
                else: raise e

            self.session.cancel_all_orders(category="linear", symbol=symbol)
            self.log("시작 전 모든 대기 주문을 취소했습니다.")
            self.last_position_state = {"size": None, "avg_price": None}
            self.tp_order_link_id = None

        except Exception as e:
            self.log(f"오류: 초기 설정에 실패했습니다 - {e}")
            self.is_running = False
            return

        is_first_run = True # 최초 실행 여부를 판단하기 위한 변수

        while self.is_running and not self.stop_event.is_set():
            try:
                side_param = self.params['side']
                position_idx_param = 1 if side_param == 'Buy' else 2

                pos_res = self.session.get_positions(category="linear", symbol=symbol, positionIdx=position_idx_param)
                position = pos_res['result']['list'][0]
                
                current_size = float(position['size'])
                avg_price = float(position['avgPrice']) if current_size > 0 else 0
                orders_res = self.session.get_open_orders(category="linear", symbol=symbol)
                open_orders = orders_res['result']['list']

                if current_size == 0:
                    # --- 최종 수정: 익절 후 와 최초 실행을 구분하는 로직 ---
                    if not is_first_run: # 최초 실행이 아닐 경우 (즉, 익절 후)
                        self.log("포지션이 익절로 종료되었습니다.")
                        self._send_email("포지션 익절", f"{symbol} 포지션이 성공적으로 종료되었습니다.")
                        
                        if len(open_orders) > 0:
                            self.log("남은 주문을 취소합니다.")
                            self.session.cancel_all_orders(category="linear", symbol=symbol)
                        
                        if self.params.get('loop', 'Yes') == 'No':
                            self.log("반복 실행이 꺼져있어 봇을 중지합니다."); self.stop(); return
                        
                        self.log("60초 후 새로운 사이클을 시작합니다.")
                        self.stop_event.wait(60)
                        if not self.is_running: break
                    
                    self.last_position_state = {"size": None, "avg_price": None}
                    self.tp_order_link_id = None
                    is_first_run = False # 다음부터는 최초 실행이 아님

                    self.log("포지션 없음. 신규 진입 및 그리드 주문을 설정합니다.")
                    steps = self.params['steps']
                    price_res = self.session.get_tickers(category="linear", symbol=symbol)
                    last_price = float(price_res['result']['list'][0]['lastPrice'])
                    
                    if self.params.get('startmarketprice', 'Yes') == 'Yes':
                        qty1 = (steps[0]['usdt'] * leverage) / last_price
                        self._place_order({"category": "linear", "symbol": symbol, "side": side_param, "orderType": "Market", "qty": qty1, "positionIdx": position_idx_param})
                        self._send_email("1차 주문 체결", f"{symbol} 포지션에 시장가로 진입했습니다.")
                        self.stop_event.wait(3)
                        pos_res = self.session.get_positions(category="linear", symbol=symbol, positionIdx=position_idx_param)
                        base_price = float(pos_res['result']['list'][0]['avgPrice']) if float(pos_res['result']['list'][0]['size']) > 0 else last_price
                    else:
                        base_price = last_price
                        qty1 = (steps[0]['usdt'] * leverage) / base_price
                        self._place_order({"category": "linear", "symbol": symbol, "side": side_param, "orderType": "Limit", "qty": qty1, "price": base_price, "positionIdx": position_idx_param})

                    current_calc_price = base_price
                    for step in steps[1:]:
                        gap_pct, money = step['gap'], step['usdt']
                        price = current_calc_price * (1 - gap_pct / 100) if side_param == 'Buy' else current_calc_price * (1 + gap_pct / 100)
                        qty = (money * leverage) / price
                        self._place_order({"category": "linear", "symbol": symbol, "side": side_param, "orderType": "Limit", "qty": qty, "price": price, "positionIdx": position_idx_param})
                        current_calc_price = price
                
                else: # 포지션이 있는 경우
                    self.log(f"포지션 보유 중 (크기: {current_size}, 평단: {avg_price}). 익절 주문을 관리합니다.")
                    position_side = position['side']
                    tp_side = 'Sell' if position_side == 'Buy' else 'Buy'
                    
                    tp_rate = self.params['profittake']
                    leverage_in_pos = float(position['leverage'])
                    
                    if position_side == 'Buy':
                        tp_price = avg_price * (1 + (tp_rate / 100 / leverage_in_pos))
                    else:
                        tp_price = avg_price * (1 - (tp_rate / 100 / leverage_in_pos))
                    
                    existing_tp_order = None
                    if self.tp_order_link_id:
                        for o in open_orders:
                            if o.get('orderLinkId') == self.tp_order_link_id:
                                existing_tp_order = o
                                break
                    
                    position_changed = (current_size != self.last_position_state.get('size')) or \
                                       (avg_price != self.last_position_state.get('avg_price'))

                    if position_changed and self.last_position_state.get("size") is not None:
                         self.log("물타기 주문 체결 감지! 포지션이 변경되었습니다.")
                         self._send_email("물타기 주문 체결", f"{symbol} 포지션 크기가 {self.last_position_state.get('size')} -> {current_size}로 변경되었습니다.")

                    if not existing_tp_order or position_changed:
                        if existing_tp_order:
                            self.log("포지션 변경 감지. 기존 익절 주문을 취소합니다.")
                            self.session.cancel_order(category="linear", symbol=symbol, orderLinkId=self.tp_order_link_id)
                        
                        self.log(f"새로운 익절 주문을 설정합니다. 가격: {tp_price}, 수량: {current_size}")
                        new_tp_id = "tp_" + ''.join(random.choices(string.ascii_letters + string.digits, k=8))
                        response = self._place_order({
                            "category": "linear", "symbol": symbol, "side": tp_side,
                            "orderType": "Limit", "qty": current_size, "price": tp_price,
                            "reduceOnly": True, "positionIdx": position_idx_param,
                            "orderLinkId": new_tp_id
                        })
                        if response:
                            self.tp_order_link_id = new_tp_id
                        
                        self.last_position_state = {"size": current_size, "avg_price": avg_price}
                    else:
                        self.log("익절 주문이 이미 올바르게 설정되어 있습니다.")

                self.stop_event.wait(15)

            except Exception as e:
                self.log(f"오류: 매매 로직 실행 중 문제 발생 - {e}")
                self.stop_event.wait(30)

===== END FILE: trading_bot.py =====
===== BEGIN FILE: templates/index.html =====
<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Bybit Cobweb Trader - GUI (Front)</title>
<style>
  :root{
    --bg:#000; --panel:#121212; --border:#2b2b2b; --text:#fff;
    --blue:#1e5eff; --blue-hover:#1649c9; --muted:#8f96a2;
    --mono: ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;
    --status-on: #22c55e; --status-off: #6b7280; --status-fail: #ef4444;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0;background:var(--bg);color:var(--text);font:14px/1.5 system-ui,-apple-system,"Segoe UI",Roboto,"Noto Sans KR","Apple SD Gothic Neo",Arial,sans-serif}
  .container{max-width:1200px;margin:0 auto;padding:12px}
  .titlebar{display:flex;justify-content:space-between;align-items:center;margin:4px 0 10px}
  .title{font-size:15px;font-weight:600}
  .status{font-size:12px;opacity:.85}
  .card{background:var(--panel);border:1px solid var(--border);border-radius:8px;margin-top:10px}
  .card-body{padding:10px 12px}
  .card-header{display:flex;justify-content:space-between;align-items:center;border-bottom:1px solid var(--border);padding:8px 12px}
  .top-line{display:flex;align-items:center;gap:12px;flex-wrap:nowrap}
  .top-line label{font-size:13px}
  .suffix{min-width:24px;text-align:center;background:#0b0b0b;border:1px solid var(--border);border-radius:6px;padding:6px 4px}
  .checkbox{display:flex;align-items:center;gap:6px;font-size:13px;margin-left:auto}
  .checkbox input{width:16px;height:16px}
  input[type="text"],input[type="number"],select,textarea{
    background:#0b0b0b; color:var(--text); border:1px solid var(--border);
    padding:6px 8px; border-radius:6px; outline:none; appearance:none;
  }
  input[disabled], input[readonly]{opacity:.7; cursor: not-allowed;}
  .btn{background:var(--blue);color:#fff;border:none;border-radius:8px;padding:8px 12px;cursor:pointer;font-weight:600}
  .btn:hover{background:var(--blue-hover)}
  .btn-sm{padding:6px 10px;font-size:13px}
  .btn-outline{background:transparent;border:1px solid var(--blue);color:#fff}
  .btn-outline:hover{background:var(--blue)}
  .step-row{display:grid;gap:8px;align-items:center; margin-bottom: 8px;
    grid-template-columns: 60px 90px 1fr 24px 100px 1fr;}
  .muted{color:var(--muted)}
  .tp-row{display:flex;align-items:center;gap:20px}
  .tp-row .inline{display:flex;gap:6px;align-items:center}
  .mono{font-family:var(--mono)}
  textarea{resize:vertical;min-height:280px;width:100%}
  .footer{display:flex;justify-content:space-between;align-items:center}
</style>
</head>
<body>
  <div class="container">

    <div class="titlebar">
      <div class="title">Bybit Cobweb Trader - GUI (Front)</div>
      <div class="status" id="statusLabel">상태: 확인 중…</div>
    </div>

    <div class="card">
      <div class="card-body">
        <div class="top-line">
          <label>심볼</label>
          <input id="ed_symbol" type="text" value="BTCUSDT" disabled style="width:120px">
          <label>방향</label>
          <select id="cmb_side" style="width:80px"><option>Long</option><option>Short</option></select>
          <label>레버리지</label>
          <input id="spn_lev" type="number" min="1" max="125" value="15" style="width:60px">
          <span class="suffix">x</span>
          <label>마진 모드</label>
          <select id="cmb_margin" style="width:140px"><option>교차(Cross)</option><option>격리(Isolated)</option></select>
          <label class="checkbox">
            <input id="chk_first" type="checkbox" checked>
            1차 시장가(진입 0 고정)
          </label>
        </div>
      </div>
    </div>

    <div class="card">
      <div class="card-header">
        <div>회차별 설정</div>
        <div>
          <button id="btn_delete" class="btn btn-sm btn-outline">삭제</button>
          <button id="btn_add" class="btn btn-sm">추가</button>
        </div>
      </div>
      <div class="card-body" id="stepsWrap"></div>
    </div>

    <div class="card">
      <div class="card-body">
        <div class="tp-row">
          <div class="inline">
            <label>익절</label>
            <input id="spn_tp" type="number" value="4.5" step="0.1" style="width:70px">
            <div class="suffix">%</div>
          </div>
          <label class="checkbox">
            <input id="chk_loop" type="checkbox" checked> 반복 실행
          </label>
        </div>
      </div>
    </div>

    <div class="card">
      <div class="card-body">
        <textarea id="txt_log" class="mono" placeholder="여기에 실행 로그가 표시됩니다." readonly></textarea>
      </div>
    </div>

    <div class="card">
      <div class="card-body footer">
        <button id="btn_save" class="btn btn-outline">설정저장</button>
        <div>
          <button id="btn_start" class="btn">봇 시작하기</button>
          <button id="btn_stop" class="btn" style="margin-left:8px; display:none;">봇 종료</button>
        </div>
      </div>
    </div>

  </div>

  <!-- JQuery 라이브러리를 먼저 불러옵니다 -->
  <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
  
  <!-- 실제 기능이 담긴 JavaScript 코드 -->
  <script>
    // 웹 페이지의 모든 요소가 로드된 후에 이 코드를 실행합니다.
    $(document).ready(function() {

        // --- 1. 자주 사용하는 HTML 요소들을 미리 찾아 변수에 저장 (효율성 증가) ---
        const elements = {
            statusLabel: $('#statusLabel'),
            symbol: $('#ed_symbol'),
            side: $('#cmb_side'),
            leverage: $('#spn_lev'),
            marginType: $('#cmb_margin'),
            firstMarket: $('#chk_first'),
            stepsWrap: $('#stepsWrap'), // 회차별 설정이 들어갈 영역
            tp: $('#spn_tp'),
            loop: $('#chk_loop'),
            logBox: $('#txt_log'),
            btnAdd: $('#btn_add'),
            btnDelete: $('#btn_delete'),
            btnSave: $('#btn_save'),
            btnStart: $('#btn_start'),
            btnStop: $('#btn_stop')
        };

        // --- 2. 로그 메시지를 화면에 표시하는 함수 ---
        function log(message) {
            const timestamp = new Date().toLocaleString();
            const currentLog = elements.logBox.val();
            // 새 로그를 맨 위에 추가합니다.
            elements.logBox.val(`[${timestamp}] ${message}\n` + currentLog);
        }

        // --- 3. 그리드 행(회차)을 동적으로 생성하는 기능 ---
        function createStepRow(index, gap, usdt) {
            // 한 줄(row)을 구성하는 HTML 코드입니다.
            const row = `
                <div class="step-row" data-index="${index}">
                    <div class="no muted">No ${String(index).padStart(2, '0')}</div>
                    <div class="muted">진입간격</div>
                    <input type="number" class="gap-input" step="0.1" value="${gap}" ${index === 1 ? 'readonly' : ''}>
                    <div class="suffix">%</div>
                    <div class="muted">회차별 증거금</div>
                    <input type="number" class="usdt-input" value="${usdt}">
                </div>`;
            return row;
        }

        function renderSteps(steps) {
            elements.stepsWrap.empty(); // 기존 행들을 모두 지웁니다.
            steps.forEach((step, idx) => {
                // 각 행을 만들어서 화면에 추가합니다.
                elements.stepsWrap.append(createStepRow(idx + 1, step.gap, step.usdt));
            });
        }

        // --- 4. 현재 화면의 모든 설정값을 하나의 객체로 수집하는 기능 ---
        function collectSettings() {
            const steps = [];
            elements.stepsWrap.find('.step-row').each(function() {
                steps.push({
                    gap: parseFloat($(this).find('.gap-input').val()),
                    usdt: parseFloat($(this).find('.usdt-input').val())
                });
            });
            return {
                symbol: elements.symbol.val(),
                side: elements.side.val() === 'Long' ? 'Buy' : 'Sell',
                leverage: parseInt(elements.leverage.val()),
                leveragetype: elements.marginType.val().includes('Cross') ? 'Cross' : 'Isolated',
                startmarketprice: elements.firstMarket.is(':checked') ? 'Yes' : 'No',
                profittake: parseFloat(elements.tp.val()),
                loop: elements.loop.is(':checked') ? 'Yes' : 'No',
                steps: steps
            };
        }

        // --- 5. 버튼 클릭 이벤트 처리 ---
        elements.btnAdd.on('click', function() {
            const newIndex = elements.stepsWrap.find('.step-row').length + 1;
            elements.stepsWrap.append(createStepRow(newIndex, 0.1, 0));
            log('회차 추가');
        });

        elements.btnDelete.on('click', function() {
            if (elements.stepsWrap.find('.step-row').length > 1) {
                elements.stepsWrap.find('.step-row:last').remove();
                log('회차 삭제');
            } else {
                log('1차는 삭제할 수 없습니다.');
            }
        });

        elements.btnSave.on('click', function() {
            const settings = collectSettings();
            localStorage.setItem('botSettings', JSON.stringify(settings));
            log('설정을 브라우저에 저장했습니다.');
        });

        function loadSettings() {
            const savedSettings = localStorage.getItem('botSettings');
            if (savedSettings) {
                const settings = JSON.parse(savedSettings);
                elements.symbol.val(settings.symbol);
                elements.side.val(settings.side === 'Buy' ? 'Long' : 'Short');
                elements.leverage.val(settings.leverage);
                elements.marginType.val(settings.leveragetype === 'Cross' ? '교차(Cross)' : '격리(Isolated)');
                elements.firstMarket.prop('checked', settings.startmarketprice === 'Yes');
                elements.tp.val(settings.profittake);
                elements.loop.prop('checked', settings.loop === 'Yes');
                renderSteps(settings.steps);
                log('저장된 설정을 불러왔습니다.');
            } else {
                const defaultSteps = [
                  {gap:0.0, usdt:41}, {gap:0.4, usdt:82}, {gap:0.8, usdt:164},
                  {gap:1.0, usdt:328}, {gap:1.5, usdt:656}, {gap:3.0, usdt:1312}, {gap:5.0, usdt:2624},
                ];
                renderSteps(defaultSteps);
            }
        }

        // --- 6. 서버와 통신하는 기능들 ---
        function checkBotStatus() {
            $.get('/status').done(function(data) {
                if (data.is_running) {
                    elements.statusLabel.text('상태: 실행중').css('color', 'var(--status-on)');
                    elements.btnStart.hide();
                    elements.btnStop.show();
                } else {
                    elements.statusLabel.text('상태: 정지').css('color', 'var(--muted)');
                    elements.btnStart.show();
                    elements.btnStop.hide();
                }
                if(data.logs && data.logs.length > 0) {
                     elements.logBox.val(data.logs.join('\n'));
                }
            }).fail(function() {
                elements.statusLabel.text('상태: 연결 실패').css('color', 'var(--status-fail)');
            });
        }

        elements.btnStart.on('click', function() {
            log('봇 시작을 요청합니다...');
            $.ajax({
                url: '/start', type: 'POST', contentType: 'application/json',
                data: JSON.stringify(collectSettings()),
                success: function(response) {
                    log('서버 응답: ' + response.message);
                    setTimeout(checkBotStatus, 1000);
                },
                error: function() { log('오류: 봇 시작 요청 실패'); }
            });
        });

        elements.btnStop.on('click', function() {
            log('봇 종료를 요청합니다...');
            $.ajax({
                url: '/stop', type: 'POST',
                success: function(response) {
                    log('서버 응답: ' + response.message);
                    setTimeout(checkBotStatus, 1000);
                },
                error: function() { log('오류: 봇 종료 요청 실패'); }
            });
        });

        // --- 7. 초기화 (페이지가 처음 로드될 때 실행되는 코드) ---
        loadSettings(); // 저장된 설정이 있으면 불러오고, 없으면 기본값으로 행 생성
        
        setInterval(checkBotStatus, 5000); // 5초마다 봇 상태를 자동으로 확인
        checkBotStatus(); // 페이지를 열자마자 즉시 상태를 확인
    });
  </script>
</body>
</html>
===== END FILE: templates/index.html =====
===== BEGIN FILE: /etc/systemd/system/bybit-bot.service =====
[Unit]
Description=Bybit Trading Bot Web Service
After=network.target

[Service]
User=smsung72
Group=smsung72
WorkingDirectory=/home/smsung72/my-trading-bot
ExecStart=/usr/bin/python3 /home/smsung72/my-trading-bot/app.py
Restart=always
RestartSec=10

[Install]
WantedBy=multi-user.target
===== END FILE: /etc/systemd/system/bybit-bot.service =====
